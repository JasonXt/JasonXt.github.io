<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[徐涛的技术博客]]></title>
  <link href="http://jasonxt.github.io/atom.xml" rel="self"/>
  <link href="http://jasonxt.github.io/"/>
  <updated>2016-02-01T16:07:57+08:00</updated>
  <id>http://jasonxt.github.io/</id>
  <author>
    <name><![CDATA[徐涛]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Laravel开胃菜 | Laravel Appetizer]]></title>
    <link href="http://jasonxt.github.io/blog/2016/02/01/laravel-appetizer/"/>
    <updated>2016-02-01T16:03:56+08:00</updated>
    <id>http://jasonxt.github.io/blog/2016/02/01/laravel-appetizer</id>
    <content type="html"><![CDATA[<h4>教程手册</h4>

<ol>
<li><a href="https://laracasts.com/series/laravel-5-fundamentals">laravel-5-fundamentals</a></li>
<li><a href="http://www.phpyc.com/search/tag/44">国内Enda袁超Laravel视频教程</a></li>
<li><a href="https://lvwenhan.com/laravel/432.html">最适合中国人的 Laravel 教程</a></li>
<li><a href="http://laravelcoding.com/blog">Laravel博客开发教程</a></li>
<li><a href="http://cheats.jesse-obrien.ca/">Laravel手册</a></li>
<li><a href="http://laravel.com/">Laravel 官方文档</a></li>
</ol>


<p>就推荐这几个，其实最重要的还是官方文档，个人建议看英文，当然也有中文翻译<a href="http://www.golaravel.com/">Laravel 中文文档</a>，这个自行选择。当然，如果你只是看文档，想深入很难，多看框架的实现代码才是王道！</p>

<h4>环境配置相关</h4>

<p>Laravel本身提供<a href="https://laravel.com/docs/5.2/homestead">Homestead</a>集成环境,很方便。
安装教程:<a href="http://www.kyomini.com/content_16.html">Windows Homestead Install</a> / <a href="http://www.kyomini.com/content_11.html">Mac Homestead Install</a>。当然如果你觉得都很麻烦，用<a href="https://www.apachefriends.org/zh_cn/index.html">XAMPP</a>/<a href="https://www.mamp.info/en/">MNPP</a>这类的也是可以的。</p>

<p>开发工具:PHPStorm必选无疑（新版的要激活了,好人做到底&ndash;><a href="http://www.xutao.win/blog/2015/11/22/phpstorm-activation/">ACTIVATION</a>）</p>

<p>断点调试：<a href="https://laracasts.com/forum/?p=1648-phpstorm-homestead-xdebug/0">Homstead+PHPStorm+XDebug</a></p>

<p>当然还有一些辅助调试的工具包，如:<a href="https://github.com/barryvdh/laravel-debugbar">barryvdh/laravel-debugbar</a>,可自行选择。</p>

<p>最后还有个头疼的<a href="https://getcomposer.org/">Composer</a> 为什么头疼?GFW啊。。。。国内太慢，Laravel install 一下能半天。。。上梯子<a href="http://pkg.phpcomposer.com/">Packagist / Composer 中国全量镜像</a> 怎么设置里面有说明。</p>

<h4>框架基础</h4>

<p>如果你之前没都没有接触过框架，不懂框架是个什么样的概念，最好自行补课，至少得明白MVC框架（Laravel是MVC框架）是个什么意思。</p>

<p>Laravel的几个必知概念点:</p>

<ul>
<li>模型（Model->Eloquent）</li>
<li>视图（View->Blade Template）</li>
<li>控制器（Controller->[Route,MiddlerWare,Request,Controller,Response]）</li>
</ul>


<p>这里我把Router、MiddleWare等也划入了Controller这个层面，我觉得这样比较好理解。</p>

<h6>模型</h6>

<p>模型基本上就是用来和数据库打交道的。但也有人喜欢在Model里封装一些相关的方法，个人不建议这么的，当然这里的小技巧一会再说。</p>

<pre><code>&lt;?php

/**
* Class Pad
* @property string brand
* @property integer RAM
* @property integer size
* @property float price
* @property \Carbon\Carbon $created_at
* @property \Carbon\Carbon $updated_at
*/
class Pad extends Eloquent
{   
    protected $table = 'pads';
}
</code></pre>

<p>这里建议把你模型的一些属性或者方法（基本就是你的数据库字段）以注释的形式写到模型类里，这样方便IDE识别或者提示。在模型类的命名空间方面需要注意的是,框架并不限制你把模型放到哪里（默认在app
目录下,5.1的命名空间为App）,这里建议是在app同级目录新建一个models目录，将这个目录用Conposer自动加载到根命名空间下。这里需要解释的是，我之所以去掉App命名空间是应为我的项目是L4.2开始的，在处理Polymorphic Relations的时候，xxxable_type里是存的根命名空间的模型类（如：User），所以这里为了省事，直接放到了根命名空间（当然还有其他方法）。</p>

<pre><code>"autoload": {
    "classmap": [
        "database"
    ],
    "psr-4": {
        "App\\": "app/",
        "":"models/"
    }
}
</code></pre>

<h5>视图</h5>

<p>视图这个其实没什么好说的，在Laravel自带的Blade模板引擎用起来还是蛮顺手的，新版的PHPStorm直接支持的比较方便</p>

<h5>控制器</h5>

<p>控制器这里我把Route,MiddlerWare,Request,Controller,Response都划分了在一起，原因是应为他们结合在一起完成了请求的处理调度响应的控制流程，可能不太科学，但个人觉得这样比较适合新人理解。</p>

<p>Route在Laravel中起到了调度请求的一个作用，就像一条条马路一样，这条道到哪里，那条到哪里。当然，路由的调度，不一定要转接给控制器，路由也可以直接返回响应(闭包)。这里有个注意点，就是在使用Laravel的 resource controller的时候，如果你需要增加自定义的路由入口到该controller，请务必写在resource 导向之前。</p>

<pre><code>Route::get('photos/popular', 'PhotoController@method');
Route::resource('photos', 'PhotoController');
</code></pre>

<p>MiddlerWare在Laravel中扮演的是一个“交警”的角色，它可以用来进行请求的一些处理前过滤，或者做请求处理后的善后工作，用法大家自行看文档吧。</p>

<p>Request在Laravel中相当于大路上行驶的车吧。他对用户的请求做了一下封装，我们可以通过facade或者依赖注入来获取Request实例，从而取得请求的参数等信息。</p>

<p>Controller是Laravel处理用户请求的处理中心，我们可以适当的把一些简单业务逻辑写在controller中，然后做出相应相应。但是我为什么说只是做一些简单的业务逻辑呢？ 当你业务逻辑太过于复杂的时候，你的代码就会相应的变成，那一个控制器的话会整个变得很长，不方便阅读;其次,这些复杂的业务逻辑如果都写在控制器的方法中，那么你很难做到复用。那这里就要用到Laravel的Repositories(5.1中是有默认文件夹的，5.2中好像是移除了默认文件夹，如果没有可自行在app目录下创建，注意遵循PSR4)，把你的业务逻辑写到Repositories中，然后在Controller中new或者依赖注入。</p>

<pre><code>&lt;?php
/**
* Created by PhpStorm.
* User: xutao
* Date: 15/8/3
* Time: 09:17
*/

namespace App\Repositories;

use Carbon\Carbon;
use Product;
use WxPayUnifiedOrder;
use WxPayOrderQuery;
use WxPayApi;
use NativePay;

class WeChatPayRepository
{
    private $user;

    public function __construct()
    {
        $this-&gt;user = \Auth::user();
    }

    /**
    *  Create Inner Order
    * @param Product|Eloquent/Model $product
    * @param $amount
    * @return array
    */
    public function createOrder($product, $amount)
    {
        //a lot of things for creating a order 
    }
}


namespace App\Http\Controllers;

use App\Repositories\WeChatPayRepository;

class DepositController extends Controller
{   
    /**
    * Create order and display the qrcode
    * @param WeChatPayRepository $repository
    * @param Request $request
    * @return \Illuminate\Http\Response
    */
    public function store(WeChatPayRepository $repository, Request $request)
    {
        $product = \Product::findOrFail(1);
        $amount = $request-&gt;get('points', 0);
        $trade = $repository-&gt;createOrder($product, $amount);
        if (!$trade) {
            //生成订单出错
        }
        $url = route('qrcode', ['url' =&gt; $trade-&gt;url]);
        return \Redirect::route('more.deposit.show', [$trade-&gt;id, 'url' =&gt; $url]);
    }
}
</code></pre>

<p>Response是最后一个点了。Response呢是Laravel对返回的一些封装，可以通过Response对象设置返回的header头，设置返回的数据等等。但是在web项目中，我们大多数返回的是视图（View），其实View渲染，然后封装成Response对象。</p>

<h4>框架进阶</h4>

<h6>IoC容器和Facades</h6>

<p>IoC容器和Facades是我们在Laravel框架中常用到的一些东西，可能新手不是太了解这个东西，如果要详细讲解起来会长，比较占篇幅，这里我给个写的不错的博文，大家可自行查看。<a href="https://www.insp.top/article/learn-laravel-container">laravel 学习笔记 —— 神奇的服务容器</a>。</p>

<ol>
<li>Container相当于一个箱子</li>
<li>Laravel在boot的时候通过ServiceProvider向箱子里面加东西，注明什么东西放在箱子的哪个地方</li>
<li>当你需要什么东西的时候，通过Facade（放入时的注明）去取得这个东西（LazyLoad|如果放入的时候已经实例化了那取得的就是实例）。</li>
</ol>


<h6>Artisan命令行</h6>

<p>Laravel提供的Artisan方便了PHP的命令行方式的交互。目前在我们项目当中Artisan用得最多的是定时的计划任务、数据的批量处理等。注意:命令行模式做数据处理，请做好最全面的异常处理或者进度保存。</p>

<p>定时计划任务:需要结合Linux的Crontab来做定时。</p>

<pre><code>sudo crontab -e

# automatic statistic 每小时的第10分钟运行一次artisan的statistic命令
10 * * * * /usr/bin/php /var/www/admin/artisan statistic
</code></pre>

<h5>Queue</h5>

<p>Laravel的队列支持database, Beanstalkd, Amazon SQS, Redis和synchronous。最后一个是本地的文件方式，默认选项，可以当做开发使用，如果是在线上部署的话，我还是推荐Beanstalkd。理由是在国内的话Amazon、SQS等就不用考虑了，Database肯定不太适合（查询效率），那就剩下Beanstalkd和Redis，二者的话性能方面应该是差不多的，但是Redis没有一个可视化的管理界面，我们不能清楚的了解队列的状态，而这点Beanstalkd却提供有可视化界面<a href="https://github.com/kr/beanstalkd/wiki/Tools">Tools</a>。这里推荐：<a href="https://github.com/ptrofimov/beanstalk_console">benstalkd_console</a>,都有现成的Docker Image Pull/Run就搞定了。</p>

<h4>总结</h4>

<p>总的来说Laravel我也用了一年多了，感觉还是顺手的（可能我接触的框架比较少，至少时候Laravel甩Think3.X几条街吧，我木有鄙视国产的意思&ndash;|），IoC容器、DI、facade等用起来也是相当爽的，扩展性也是杠杠的，需要是什么扩展包去packagist或者git上找一找，require一下就OK了，所以在开发上会省很多造轮子的时间。</p>

<p>值得一提的是最近出了<a href="https://lumen.laravel.com/">Lumen5.2</a>(Laravel的精简版，最新版本基本上以API为目标了)，那用Laravel做API也是66的了，大家可以去尝试下。（之前我是用的L4.2+<a href="https://github.com/dingo/api">dingo API</a>做的）</p>

<p>Any way ，先说这么多等以后有想到什么再来补充吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在ubuntu上安装PHP7.0]]></title>
    <link href="http://jasonxt.github.io/blog/2015/12/16/an-zhuang-php7/"/>
    <updated>2015-12-16T21:45:01+08:00</updated>
    <id>http://jasonxt.github.io/blog/2015/12/16/an-zhuang-php7</id>
    <content type="html"><![CDATA[<p>PHP7.0 发布啦! 等了几天,今天来尝尝鲜,哈哈!</p>

<p>这玩意据说比HHVM还快了啊.下面我们就来装个体验下.</p>

<p>卸载PHP5</p>

<p><code>sudo apt-get remove php5* &amp;&amp; apt-get purge php5-fpm &amp;&amp; apt-get --purge autoremove &amp;&amp;</code></p>

<p>添加 PHP7的PPA源</p>

<p><code>apt-get install python-software-properties software-properties-common</code>
<code>sudo add-apt-repository ppa:ondrej/php-7.0</code></p>

<p>安装
<code>apt-get update &amp;&amp; apt-get install php7.0-fpm php7.0-mysql</code></p>

<p>如果你安装的是Apache 这样</p>

<p><code>apt-get install libapache2-mod-php7.0</code>
<code>a2enmod php7.0</code>
<code>service apache2 restart</code></p>

<p>好了,大工告成.当然,还可以做一些优化:
<a href="http://www.laruence.com/2015/12/04/3086.html" title="让PHP7达到最高性能的几个Tips">鸟叔大神的帖子</a>  让PHP7达到最高性能的几个Tips.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHPSTORM ACTIVATION 注册激活]]></title>
    <link href="http://jasonxt.github.io/blog/2015/11/22/phpstorm-activation/"/>
    <updated>2015-11-22T23:20:00+08:00</updated>
    <id>http://jasonxt.github.io/blog/2015/11/22/phpstorm-activation</id>
    <content type="html"><![CDATA[<p>最近新出了PHPSTORM10，于是把自己机器上的升级了下。这家伙收费的，国人嘛。。。你懂的。</p>

<p>安装后，发现不能用原来的keygen注册激活了，于是Google了一下，下面是解决方案：</p>

<p>安装好打开的时候，弹出注册界面 License Activation 选择第二个选项
License Server,在address里面填下面的url</p>

<p><code>http://idea.lanyus.com/</code></p>

<p>然后点击OK 就行啦</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MAC下解决PHPSTORM的Case-Sensitivity]]></title>
    <link href="http://jasonxt.github.io/blog/2015/11/16/phpstorm-and-and-webstormjie-jue-case-sensitivity/"/>
    <updated>2015-11-16T17:35:38+08:00</updated>
    <id>http://jasonxt.github.io/blog/2015/11/16/phpstorm-and-and-webstormjie-jue-case-sensitivity</id>
    <content type="html"><![CDATA[<p>由于最近重装了MAC的系统,在安装时选择了区分大小写的存储格式,在打开idea 这类的IDE的时候会出现警告.这里提供一个解决的方法：</p>

<p>以PHPSOTRM为例：</p>

<ul>
<li>Finder 中打开应用程序,找到PHPSTORM，右击显示包内容，找到
<code>Contents/bin/idea.properties</code>文件，用编辑器打开；</li>
<li>在最后加上<code>idea.case.sensitive.fs=true</code>,然后保存。
重启PHPSTORM，警告就消失了。</li>
</ul>

]]></content>
  </entry>
  
</feed>
